<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 3.0响应式自己实现 | 前端学习</title>
    <meta name="description" content="前端技术底层实现">
    
    
    <link rel="preload" href="/vue-source-code-analysize/assets/css/0.styles.6bdd7a3f.css" as="style"><link rel="preload" href="/vue-source-code-analysize/assets/js/app.b763ca3b.js" as="script"><link rel="preload" href="/vue-source-code-analysize/assets/js/2.d9983486.js" as="script"><link rel="preload" href="/vue-source-code-analysize/assets/js/4.859fd439.js" as="script"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/10.647aa5c0.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/11.c33a6322.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/12.fb125ffe.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/13.c788a33f.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/14.da7cfa92.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/15.9e7ba6b6.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/16.a6c3c4a5.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/17.6199def5.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/18.52b45891.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/19.4e9eea1b.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/20.daa69c1d.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/21.5bc4eca1.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/22.2c21b5ba.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/23.81195dcf.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/24.cb0b0283.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/25.aaeb364b.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/3.f763d6bc.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/5.6a87b23f.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/6.4b3a66c2.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/7.c0610b4a.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/8.e2299770.js"><link rel="prefetch" href="/vue-source-code-analysize/assets/js/9.da2cd365.js">
    <link rel="stylesheet" href="/vue-source-code-analysize/assets/css/0.styles.6bdd7a3f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-source-code-analysize/" class="home-link router-link-active"><!----> <span class="site-name">前端学习</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/limingkang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  gitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/limingkang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  gitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/vue-source-code-analysize/" class="sidebar-heading clickable router-link-active open"><span>vue3源码</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-source-code-analysize/techAccumulate/vue-rfc.html" class="active sidebar-link">vue3和2响应式对比</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-source-code-analysize/techAccumulate/vue-rfc.html#简单api介绍" class="sidebar-link">简单API介绍</a></li><li class="sidebar-sub-header"><a href="/vue-source-code-analysize/techAccumulate/vue-rfc.html#vue2-x响应式原理" class="sidebar-link">vue2.x响应式原理</a></li><li class="sidebar-sub-header"><a href="/vue-source-code-analysize/techAccumulate/vue-rfc.html#vue3-0的响应式" class="sidebar-link">Vue3.0的响应式</a></li><li class="sidebar-sub-header"><a href="/vue-source-code-analysize/techAccumulate/vue-rfc.html#参考文章" class="sidebar-link">参考文章</a></li></ul></li><li><a href="/vue-source-code-analysize/vueReactive/code-analsize.html" class="sidebar-link">vue3响应式源码讲解</a></li><li><a href="/vue-source-code-analysize/easyInit/init.html" class="sidebar-link">核心渲染函数介绍</a></li><li><a href="/vue-source-code-analysize/render/render.html" class="sidebar-link">渲染流程介绍</a></li><li><a href="/vue-source-code-analysize/domDiff/dom-diff.html" class="sidebar-link">dom diff</a></li><li><a href="/vue-source-code-analysize/compiler/compiler.html" class="sidebar-link">编译函数介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>vuex源码</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-source-code-analysize/vuex/vuex-start.html" class="sidebar-link">vuex初识</a></li><li><a href="/vue-source-code-analysize/vuex/vuex-module.html" class="sidebar-link">vuex模块部分</a></li><li><a href="/vue-source-code-analysize/vuex/vuex-analyzed.html" class="sidebar-link">初始化挂载vue</a></li><li><a href="/vue-source-code-analysize/vuex/vuex-api.html" class="sidebar-link">实例的api</a></li><li><a href="/vue-source-code-analysize/vuex/vuex-help.html" class="sidebar-link">辅助函数介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>vue-router源码</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-source-code-analysize/vueRouter/start.html" class="sidebar-link">整体介绍</a></li><li><a href="/vue-source-code-analysize/vueRouter/two.html" class="sidebar-link">路由原理</a></li><li><a href="/vue-source-code-analysize/vueRouter/three.html" class="sidebar-link">路由守卫的生成</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>源码实现</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-source-code-analysize/webpack/webpack.html" class="sidebar-link">webpack打包原理</a></li><li><a href="/vue-source-code-analysize/promise/promise.html" class="sidebar-link">promise</a></li><li><a href="/vue-source-code-analysize/promise/await.html" class="sidebar-link">async、await原理</a></li><li><a href="/vue-source-code-analysize/promise/class.html" class="sidebar-link">class原理</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-3-0响应式自己实现"><a href="#vue-3-0响应式自己实现" class="header-anchor">#</a> Vue 3.0响应式自己实现</h1> <h2 id="简单api介绍"><a href="#简单api介绍" class="header-anchor">#</a> 简单API介绍</h2> <p>vue3.0相比较于2.x版本，api的用途都是一致的，只不过我们写法变了。
github地址：https://github.com/vuejs/vue-next，下载安装依赖，我们先来用一个简单的例子介绍下新API：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">usePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> position <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span>y<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      position<span class="token punctuation">.</span>x <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX<span class="token punctuation">;</span>
      position<span class="token punctuation">.</span>y <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  Vue<span class="token punctuation">.</span><span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span> <span class="token comment">// 生命周期函数</span>
      window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span>update<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  Vue<span class="token punctuation">.</span><span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
      window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span>update<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Vue<span class="token punctuation">.</span><span class="token function">toRefs</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> App <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 类似于created , 只会执行一次</span>
    <span class="token keyword">let</span> state <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'syh'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 响应式</span>
    <span class="token keyword">let</span> position <span class="token operator">=</span> <span class="token function">usePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// methods</span>
      state<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'syh1'</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token comment">// 这个对象会作为渲染的上下文</span>
      state<span class="token punctuation">,</span>
      change<span class="token punctuation">,</span>
      <span class="token operator">...</span>position <span class="token comment">// 这个地方使用解构的方式获取值，所以上面要使用toRefs方法，保证结构出来的值也是响应式的</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div @click=&quot;change&quot;&gt;{{state.name}} x:{{x}} y{{y}}&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span>
Vue<span class="token punctuation">.</span><span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span>App<span class="token punctuation">,</span>container<span class="token punctuation">)</span>  <span class="token comment">// 使用createApp方法</span>
</code></pre></div><p>在上述例子中，usePosition方法是我们抽离出来的公共函数，里面的属性和setUp里面的一致，在vue2.x版本，我们只能通过mixin/高阶组件/插槽等方式来实现，但是均有问题，具体介绍可以参考：https://zhuanlan.zhihu.com/p/68477600</p> <p>Vue3.0这种方式，更方便组件之间逻辑的抽取和复用。</p> <blockquote><p>API更详细的使用方式，请看参考链接，这边就不一一 列举了</p></blockquote> <h2 id="vue2-x响应式原理"><a href="#vue2-x响应式原理" class="header-anchor">#</a> vue2.x响应式原理</h2> <p>首先我们先复习下vue2.x的响应式原理(文字描述太费劲，直接上代码)：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 对数组单独处理</span>
<span class="token keyword">let</span> oldArrayPrototype <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
<span class="token keyword">let</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>oldArrayPrototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 继承</span>
<span class="token punctuation">[</span><span class="token string">'push'</span><span class="token punctuation">,</span><span class="token string">'shift'</span><span class="token punctuation">,</span><span class="token string">'unshift'</span><span class="token punctuation">,</span> <span class="token string">'pop'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">method</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  proto<span class="token punctuation">[</span>method<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 把函数进行重写 内部 继续调用老的方法</span>
    <span class="token function">updateView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// AOP  更新视图</span>
    oldArrayPrototype<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span> <span class="token comment">// 调用原始数组方法</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">observer</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> target <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> target <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> target<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 拦截数组 给数组的方法进行了重写</span>
    Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 修改数组方法 target.__proto__ = proto;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> target<span class="token punctuation">.</span>length <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">observer</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 循环数组每一项</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">defineReactive</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 给对象每一项添加get和set方法</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span><span class="token punctuation">{</span>
    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// get 中会进行依赖收集</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>newValue <span class="token operator">!==</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">observer</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span>  <span class="token comment">// 设置新属性的时候，也需要递归</span>
            <span class="token function">updateView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            value <span class="token operator">=</span> newValue
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">updateView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'更新视图'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'syh'</span><span class="token punctuation">,</span>age<span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
<span class="token function">observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span>age<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>以上响应式过程有以下几个问题</strong>：</p> <ol><li>循环递归的地方很多，浪费性能</li> <li>数组需要独立处理，且数组改变length是无效的。</li> <li>获取对象不存在的属性会被拦截</li></ol> <h2 id="vue3-0的响应式"><a href="#vue3-0的响应式" class="header-anchor">#</a> Vue3.0的响应式</h2> <h3 id="reactive"><a href="#reactive" class="header-anchor">#</a> reactive</h3> <p>上面Vue3.0的例子中，<code>reactive</code>是用来实现响应式的，我们就从这个api开始，使用<code>Proxy</code>实现一个简单的数据劫持</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isObject</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> val <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 创建响应式对象</span>
	<span class="token keyword">return</span> <span class="token function">createReactiveObject</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createReactiveObject</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> target<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 如果不是对象，直接返回</span>
	<span class="token comment">// 数据劫持</span>
	<span class="token keyword">let</span> observed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span>
		<span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 删除</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'delete'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> observed<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 代理对象</span>
<span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'syh'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'syn1'</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span> proxy<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>a
</code></pre></div><p>以上，便是一个最简的利用proxy进行数据劫持的过程，打印结果如下：
<img src="/vue-source-code-analysize/assets/img/1.8bd85c51.png" alt="An image"></p> <p>分别触发了get、set、delete方法。
注意，get方法被触发了两次，最后一次调用<code>proxy.a</code>，也触发了get方法，但是proxy并没有a属性。说明<strong>获取对象不存在的属性，也可以触发get方法</strong>。</p> <h3 id="get、set、deleteproperty"><a href="#get、set、deleteproperty" class="header-anchor">#</a> get、set、deleteProperty</h3> <p>接下来我们来完善get、set、deleteProperty方法。
get方法有3个参数：</p> <ol><li>target--原对象</li> <li>key--代理的key</li> <li>receiver--代理后获得的对象，reactive的返回值proxy</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>但是vue3.0版本并不是这样用，而是用了一个Reflect的API(http://es6.ruanyifeng.com/#docs/reflect)，set、delete方法中也一样。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> observed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span>
	<span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">)</span>
    <span class="token comment">// Reflect.set方法会有一个返回值，为boolean类型，告诉你这个值是否设置成功</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 删除</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'delete'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> observed<span class="token punctuation">;</span>
</code></pre></div><p><img src="/vue-source-code-analysize/assets/img/2.63ccb922.png" alt="An image"></p> <p>此时，数组也可被代理：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 代理对象</span>
<span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>执行结果(触发次数过多的问题后面会解决，这边先不管)：
<img src="/vue-source-code-analysize/assets/img/3.d6fd9997.png" alt="An image"></p> <p><strong>如果当前代理的对象不是一层，是多层呢？</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 代理对象</span>
<span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token punctuation">{</span> firstName<span class="token operator">:</span> <span class="token string">'syh'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>name<span class="token punctuation">.</span>firstName <span class="token operator">=</span> <span class="token string">'s'</span><span class="token punctuation">;</span>
</code></pre></div><p>打印结果：js
<img src="/vue-source-code-analysize/assets/img/4.0acc67ec.png" alt="An image"></p> <p>结果并没有打印set方法，但是我们看到，打印了get方法。因为我们获取firstName这个属性的时候，先调用了name，就触发了name的get。所以，我们可以在get方法里面，获取他子对象的代理。<strong>总结来说，vue3.0的递归，不是在初始化的时候就将所有属性都递归一遍进行双向绑定，而是你取值的时候，再绑定</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// result 就是当前获取到的值，此时如果result是个对象，那对result再进行一次绑定</span>
  <span class="token keyword">return</span> <span class="token function">isObject</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">reactive</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">:</span> result<span class="token punctuation">;</span>   <span class="token comment">// 递归</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>打印结果：
<img src="/vue-source-code-analysize/assets/img/5.b2132929.png" alt="An image"></p> <h3 id="解决重复代理问题"><a href="#解决重复代理问题" class="header-anchor">#</a> 解决重复代理问题</h3> <p>如果用户写了如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 代理对象</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token punctuation">{</span> firstName<span class="token operator">:</span> <span class="token string">'syh'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">reactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">reactive</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>会自然产生以下两个疑问：</p> <ol><li>我们每调用一次reactive方法，都会new一个proxy对象，然后返回，如何避免重复代理同一个对象？</li> <li>如果reactive里面传入的是一个已代理过的对象呢？</li></ol> <p>我们使用两个映射表来解决这两个个问题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> toProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 映射关系 原对象：代理后的对象</span>
<span class="token keyword">let</span> toRow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 映射关系 代理后的对象：原对象</span>
<span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">// 赋值</span>
toProxy<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> observed<span class="token punctuation">)</span><span class="token punctuation">;</span>
toRow<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>observed<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> observed<span class="token punctuation">;</span>
</code></pre></div><blockquote><p>weakMap具体内容，可参考：https://github.com/mqyqingfeng/Blog/issues/92</p></blockquote> <p>所以，在进行数据劫持之前，要看下weakmap里面是否有值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> proxy <span class="token operator">=</span> toProxy<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>proxy<span class="token punctuation">)</span> <span class="token keyword">return</span> proxy<span class="token punctuation">;</span>  <span class="token comment">// 如果已经代理过了，直接将代理结果返回</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>toRow<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> target<span class="token punctuation">;</span>  <span class="token comment">// 此时 target如果是observe，是一个已经代理过的对象，那就直接返回</span>
</code></pre></div><h3 id="解决数组的get和set多次触发问题"><a href="#解决数组的get和set多次触发问题" class="header-anchor">#</a> 解决数组的get和set多次触发问题</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 代理对象</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>打印结果如下：
<img src="/vue-source-code-analysize/assets/img/6.3916077f.png" alt="An image"></p> <p>打印了2次的get和set，我们先来看set函数，在set里面打印下key、value：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// console.info('set')</span>
  console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Reflect.set方法会有一个返回值，为boolean类型，告诉你这个值是否设置成功</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>打印结果为：
<img src="/vue-source-code-analysize/assets/img/7.65de5494.png" alt="An image"></p> <p>可以看见，key分别为3和length，第一次的key是数组下标3，value是值4；第二次修改数组的length属性。所以，触发了两次set。
我们需要屏蔽修改length的set，那就要区分当前数组是修改属性还是新增属性。如果是修改，那么target属性里面肯定会有对应的key：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> target<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用oldValue记录老值，value为新的值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hasKey <span class="token operator">=</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> oldValue <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 记录老值</span>
  <span class="token comment">// Reflect.set方法会有一个返回值，为boolean类型，告诉你这个值是否设置成功</span>
  console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// console.info(oldValue, value);</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasKey<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 原有数组里面没这个属性，表示新增值</span>
    console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'新增'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">!==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 表示修改属性</span>
    console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'修改属性'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>以上，数组重复调用的问题也解决了。下面我们来看依赖收集。</p> <h3 id="依赖收集"><a href="#依赖收集" class="header-anchor">#</a> 依赖收集</h3> <p>Vue3.0依赖收集的核心，依旧是发布订阅。我们先回顾下Vue2.0的依赖收集过程。</p> <h4 id="vue2-0中的依赖收集"><a href="#vue2-0中的依赖收集" class="header-anchor">#</a> Vue2.0中的依赖收集</h4> <p>首先我们先写个简单的发布订阅：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>dep <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存放所有依赖</span>
<span class="token punctuation">}</span>

<span class="token class-name">Dep</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">addSub</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 这个fn添加的就是watcher</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Dep</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">notify</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
		fn<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//  触发页面元素更新。Dep的notify方法都是在数据劫持的set里面操作。update就是更新的方法</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>vue2.0在模板编译的时候，会根据模板内容，动态生成Watcher的实例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> RegExp<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 数据变动后的回调，一般都是修改dom</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>Watcher类实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Watcher</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span>exp<span class="token punctuation">,</span>fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>fn <span class="token operator">=</span> fn<span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm<span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>exp <span class="token operator">=</span> exp<span class="token punctuation">;</span>
	Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> val <span class="token operator">=</span> vm<span class="token punctuation">;</span>
	<span class="token keyword">let</span> arr <span class="token operator">=</span> exp<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 取值的时候，会调用get方法，在get方法里面完成依赖收集</span>
		val <span class="token operator">=</span> val<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
	Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>每一个watcher都有一个update方法，用户更新数据后，update方法先获取更新后的值，然后执行回调：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Watcher</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">update</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 先获取更新后的值</span>
	<span class="token keyword">let</span> val <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">;</span>
	<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>exp<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		val <span class="token operator">=</span> val<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token comment">// 执行更新dom的回调</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在get方法里面进行依赖收集，在set方法里面触发更新：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span><span class="token punctuation">{</span>
  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    Dep<span class="token punctuation">.</span>target<span class="token operator">&amp;&amp;</span>dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 完成依赖收集</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>newValue <span class="token operator">!==</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
      value <span class="token operator">=</span> newValue
      <span class="token function">observer</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span>  <span class="token comment">// 设置新属性的时候，也需要递归</span>
      dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 让所有watcher的update方法执行</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>总结</strong>:
可以理解为vue2.0里面data的每一个属性以及它的子属性，都对应了一个watcher，修改属性的时候，就触发了本身的set方法，然后通知Dep的notify，然后执行相应的update方法。</p> <p>Watcher主要做了以下操作：</p> <ol><li>通过参数vm以及传过来的exp，获取newValue</li> <li>将当前对象对应的watcher实例赋值给Dep.target</li> <li>从vm获取newValue，会触发get方法，在get里面完成依赖收集</li> <li>将Dep.target = null; 当前属性依赖收集完毕。</li></ol> <p>Watcher的updata方法：</p> <ol><li>通过new Watcher传过来的vm以及exp，获取最新的值</li> <li>将newVal最为参数，执行new Watcher传过来的回调方法，更新dom</li></ol> <h4 id="vue3-0中的依赖收集"><a href="#vue3-0中的依赖收集" class="header-anchor">#</a> Vue3.0中的依赖收集</h4> <p>总体结构图：
<img src="/vue-source-code-analysize/assets/img/8.dea9956d.png" alt="An image"></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'syh'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'s'</span><span class="token punctuation">;</span>
</code></pre></div><p>我们需要做两件事情</p> <ol><li>初始化依赖收集</li> <li>更新属性后执行update方法</li></ol> <p>Vue3.0新增一个effect方法，来实现这两个功能。
effect方法应该执行两次，第一次依赖收集，第二次更新属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name：<span class="token string">'syh'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 会执行2次</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'s'</span><span class="token punctuation">;</span>
</code></pre></div><p>在vue2.0中，通过set方法触发所有watcher的回调，在3.0中，当属性值发生变动后，直接触发对应的effect方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 需要将fn做成响应式的，当属性变动后，就执行函数</span>
	<span class="token keyword">let</span> effect <span class="token operator">=</span> <span class="token function">createReactiveEffect</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 创建完之后，要默认执行一次</span>
	<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接下来，我们看createReactiveEffect的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createReactiveEffect</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 创建一个响应式effect</span>
	<span class="token keyword">let</span> <span class="token function-variable function">effect</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// run方法有两个目的 1. 执行fn 2. 将effect存到栈activeEffectStact中，数据更新后，重新执行该函数</span>
		<span class="token keyword">return</span> <span class="token function">run</span><span class="token punctuation">(</span>effect，fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> effect<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token parameter">effect<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	activeEffectStact<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们在run方法里面执行了fn()，fn里面获取了属性值，那就会触发属性的get方法，我们可以将当前属性名和对应的effect方法关联 <code>{name: [effect]}</code>，这样，某一个属性变化后，就可以直接执行它对应的effect方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// console.info('get');</span>
  <span class="token comment">// console.info(key);</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// result 就是当前获取到的值，此时如果result是个对象，那对result再进行一次绑定</span>

  <span class="token comment">// 依赖收集，将当前的属性和effect对应起来，如果这个key变化了，重新让数组中的effect执行</span>
  <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token function">isObject</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">reactive</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">:</span> result<span class="token punctuation">;</span>   <span class="token comment">// 递归</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>在track方法里面，我们要生成这么一个对应关系：</p> <div class="language-js extra-class"><pre class="language-js"><code>target<span class="token operator">:</span> <span class="token punctuation">{</span>
	key<span class="token operator">:</span> <span class="token punctuation">[</span>effect1<span class="token punctuation">,</span> effect2<span class="token operator">...</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="/vue-source-code-analysize/assets/img/9.451bbb8b.png" alt="An image"></p> <p>整体是个weakMap，target为key，value值是一个Map，Map的key是普通属性，value是一个set，里面存放的就是对应的effect</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> targetsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 如果属性值变化，就执行activeEffectStact里面的effect方法</span>
<span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 取数组最后一个</span>
	<span class="token keyword">let</span> effect <span class="token operator">=</span> activeEffectStact<span class="token punctuation">[</span>activeEffectStact<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 先看这个target有没有</span>
		<span class="token keyword">let</span> depsMap <span class="token operator">=</span> targetsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			targetsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> depsMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 再看这个key有没有</span>
		<span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> deps<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 将activeEffectStact中的effect放到deps里面</span>
		<span class="token comment">// 先判断deps里面有没有effect</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">.</span><span class="token function">hans</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>加完一个effect，就要从栈里面清掉一个</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token parameter">effect<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">try</span> <span class="token punctuation">{</span>
		activeEffectStact<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加try catch是为了防止fn报错</span>
	<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
		<span class="token comment">// 数组放完一个后，执行pop</span>
		activeEffectStact<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>更新的话，会调用set方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hasKey <span class="token operator">=</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> oldValue <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 记录老值</span>
  <span class="token comment">// Reflect.set方法会有一个返回值，为boolean类型，告诉你这个值是否设置成功</span>
  console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// console.info(oldValue, value);</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasKey<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 原有数组里面没这个属性，表示新增值</span>
    console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'新增'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行更新操作</span>
    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token string">'add'</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">!==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 表示修改属性</span>
    console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'修改属性'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token string">'set'</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 取出属性对应的effect执行</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> type<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> depsMap <span class="token operator">=</span> targetsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			deps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effect</span> <span class="token operator">=&gt;</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 将属性对应的effect执行</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上，vue3.0依赖收集已全部完成。</p> <h2 id="参考文章"><a href="#参考文章" class="header-anchor">#</a> 参考文章</h2> <h4 id="vue3-0-api介绍："><a href="#vue3-0-api介绍：" class="header-anchor">#</a> vue3.0 Api介绍：</h4> <ol><li>https://zhuanlan.zhihu.com/p/68477600</li> <li>https://github.com/xingbofeng/xingbofeng.github.io/issues/45</li></ol> <h4 id="vue3-0源码介绍："><a href="#vue3-0源码介绍：" class="header-anchor">#</a> vue3.0源码介绍：</h4> <ol><li>https://juejin.im/post/5d99be7c6fb9a04e1e7baa34#heading-6</li> <li>https://juejin.im/post/5d977f47e51d4578453274b3</li></ol> <h4 id="其他："><a href="#其他：" class="header-anchor">#</a> 其他：</h4> <ol><li>https://github.com/mqyqingfeng/Blog/issues/92</li> <li>https://github.com/coolriver/coolriver-site/blob/master/markdown/vue-mixin-hoc.md</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/vue-source-code-analysize/vueReactive/code-analsize.html">vue3响应式源码讲解</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vue-source-code-analysize/assets/js/app.b763ca3b.js" defer></script><script src="/vue-source-code-analysize/assets/js/2.d9983486.js" defer></script><script src="/vue-source-code-analysize/assets/js/4.859fd439.js" defer></script>
  </body>
</html>
